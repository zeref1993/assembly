;while giving string as input give exactly 5 characters,
; don't press space at end

NAME CONNECT4
.STACK 100
.MODEL SMALL

MY_DATA_SEGMENT SEGMENT

  PROMPT DB 'Enter a string   e.g. p1 c3  $'
	MESSAGE DB 'Invalid format$'
	FMES DB '  WON $'
	PLAY1 DB 'Player 1$'
	PLAY2 DB 'Player 2$'
	PROMPT1 DB 'Player1 turn                  $'
	PROMPT2 DB 'Player2 turn                  $'
	CLEAR DB 30 DUP(' '),'$'
	BUFF DB 51,0, 51 DUP('$')
	TEMP DW 0
	TEMPB DB 0
	TEMPB2 DB 0
	ROW_TOP DB 0
	ROW_END DB 0
	COL_START DB 0
	COL_END DB 0
	CURR_PLAYER DB 0
	CURR_COL DB 0
	COLOR DB 0
	HEIGHT DB 6 DUP(5)
	TROW DB 0
	TCOL DB 0
	PROW DB 12 DUP(0)
	PCOL DB 12 DUP(0)
	PDIAG1 DB 10 DUP(0)
	PDIAG2 DB 10 DUP(0)
	TEMPP DB 0
	TEMPU DB 0

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;                 LIST OF MACROS                ;;;;;;;;;
  
	SET_CURSOR MACRO ROW, COL
		PUSH AX
		PUSH BX
		PUSH CX
		PUSH DX
		
		MOV AH, 02H
		MOV DH, ROW
		MOV DL, COL
		MOV BH, 0
		INT 10H
		
		POP DX
		POP CX
		POP BX
		POP AX
	ENDM
	
	SET_VIDEO_MODE MACRO MODE
		PUSH AX
	
		MOV AL, MODE
		MOV AH, 0
		INT 10H
		
		POP AX		
	ENDM
	
	DRAW_HLINE MACRO ROW, COL,LEN
		PUSH AX
		PUSH BX
		PUSH CX
		PUSH DX
		
		MOV BX, COL
		HDRAW:
			MOV AL, 0CH
			MOV CX, BX
			MOV DX, ROW
			MOV AH, 0CH
			INT 10H
			INC BX
			CMP BX, LEN
			JLE HDRAW
		
		POP DX
		POP CX
		POP BX
		POP AX
	ENDM
	
	DRAW_VLINE MACRO ROW, COL,LEN
		PUSH AX
		PUSH BX
		PUSH CX
		PUSH DX
		
		MOV BX, ROW
		VDRAW:
			MOV AL, 0CH
			MOV CX, COL
			MOV DX, BX
			MOV AH, 0CH
			INT 10H
			INC BX
			CMP BX, LEN
			JLE VDRAW
		
		POP DX
		POP CX
		POP BX
		POP AX
	ENDM
	
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;                 END OF MACROS                ;;;;;;;;;	
MY_DATA_SEGMENT ENDS



MY_CODE_SEGMENT SEGMENT
  ASSUME CS:MY_CODE_SEGMENT, DS:MY_DATA_SEGMENT
START:

	MOV AX, MY_DATA_SEGMENT
	MOV DS, AX

	CALL INITL
	CALL TAKE_INPUT	
	
	SET_VIDEO_MODE 03H
  
	MOV AX, 4C00H
	INT 21H	  
  
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;                 LIST OF PROCEDURES                 ;;;;;;;;;
; INITIALISES THE GAME
; USED WHEN WE WANT NEW GAME
INITL PROC NEAR
	PUSH AX
	PUSH BX
	PUSH CX
	PUSH DX
	
	SET_VIDEO_MODE 13H
	CALL COLOR_SCREEN
  
	
	MOV CX, 7
	MOV TEMP, 50
	HORIZONTAL:
		DRAW_HLINE TEMP,100,220
		ADD TEMP, 20
		LOOP HORIZONTAL
	
	MOV CX, 7
	MOV TEMP, 100
	VERTICAL:
		DRAW_VLINE 50,TEMP,170
		ADD TEMP, 20
		LOOP VERTICAL
	
	MOV TEMP ,0
	MOV TEMPB ,0
	MOV TEMPB2 ,0
	MOV ROW_TOP , 0
	MOV ROW_END , 0
	MOV COL_START , 0
	MOV COL_END , 0
	MOV CURR_PLAYER , 2
	MOV CURR_COL ,0
	MOV COLOR , 0
	MOV TROW , 0
	MOV TCOL , 0
	MOV TEMPP , 0
	MOV TEMPU , 0
	
	MOV CX, 6
	MOV BX, 0
	HINIT:
		MOV HEIGHT[BX], 5
		INC BX
		LOOP HINIT
	
	MOV CX, 12
	MOV BX, 0
	RCINIT:
		MOV PROW[BX], 0
		MOV PCOL[BX], 0
		INC BX
		LOOP RCINIT
	
	MOV CX, 10
	MOV BX, 0
	DINIT:
		MOV PDIAG1[BX], 0
		MOV PDIAG2[BX], 0
		INC BX
		LOOP DINIT
	
	POP DX
	POP CX
	POP BX
	POP AX
	RET
INITL ENDP
  
COLOR_SCREEN PROC NEAR
	PUSH AX
	PUSH BX
	PUSH CX
	PUSH DX
	
        MOV AX, 0600H
        MOV BH, 3BH
        MOV CX, 0H
        MOV DX, 184FH
        INT 10H
	
	POP DX
	POP CX
	POP BX
	POP AX
        RET
COLOR_SCREEN ENDP

;TAKES INPUT
;while giving string as input give exactly 5 characters,
; don't press space at end
TAKE_INPUT PROC NEAR
	PUSH AX
	PUSH BX
	PUSH CX
	PUSH DX
	
	
	REDO:
	SET_CURSOR 0,5
	LEA DX, PROMPT1
	CMP CURR_PLAYER, 2
	JZ UI
	LEA DX, PROMPT2
	UI:
		MOV AH, 09H
		INT 21H
		SET_CURSOR 1,5
		MOV AH, 0AH
		LEA DX, BUFF
		INT 21H
	
		CMP BUFF[2], 'n'
		JE NGAME
		CMP BUFF[2], 'N'
		JNE OGAME
	NGAME:
		CALL INITL
		JMP REDO
	OGAME:	
		CMP BUFF[2], 'e'
		JE OEXIT
		CMP BUFF[2], 'E'
		JNE NEXIT
	OEXIT:
		POP DX
		POP CX
		POP BX
		POP AX
		RET
	NEXIT:
		CMP BUFF[1], 5
		JNE ASSISTJ
		CMP BUFF[2], 'P'
		JE PCHK
		CMP BUFF[2],'p'
		JNE ASSISTJ
	PCHK:
		CMP BUFF[3], '1'
		JL ASSISTJ
		CMP BUFF[3], '2'
		JG ASSISTJ
		SUB BUFF[3], '0'
		MOV AL, BUFF[3]
		CMP CURR_PLAYER, AL
		JE ASSISTJ
		MOV BL, AL

	
	CMP BUFF[4], ' '
	JNE ASSISTJ
	
	CMP BUFF[5], 'C'
	JE CCHK
	CMP BUFF[5],'c'
	JNE INVALID
	CCHK:
		MOV AL, BUFF[6]
		MOV CURR_COL, AL
		SUB CURR_COL, '0'
		DEC CURR_COL
		CMP AL, '1'
		JL INVALID
		CMP AL, '6'
		JG INVALID
		MOV CL,BL
	
		JMP SKIP
	ASSISTJ:
		JMP INVALID
	SKIP:

		SET_CURSOR 1, 5
		MOV AH, 09H
		LEA DX, CLEAR
		INT 21H
		MOV BH, 0
		MOV BL, CURR_COL
		MOV AL, HEIGHT[BX]
		MOV TEMPB2, AL
		CMP TEMPB2, 0
		JL INVALID
		DEC HEIGHT[BX]
		MOV CURR_PLAYER, CL
		CALL CROSS_CELL 
		SET_CURSOR 4,5
		MOV AH, 09H
		LEA DX, CLEAR
		INT 21H
		JMP REDO
	
	
	
	INVALID:
		SET_CURSOR 1, 5
		MOV AH, 09H
		LEA DX, CLEAR
		INT 21H
		SET_CURSOR 4,5
		MOV AH, 09H
		LEA DX, MESSAGE
		INT 21H
		JMP REDO
	
	
	POP DX
	POP CX
	POP BX
	POP AX
	RET
TAKE_INPUT ENDP

; USED TO DRAW CROSS ON REQUIRED CELL
CROSS_CELL PROC NEAR
	PUSH AX
	PUSH BX
	PUSH CX
	PUSH DX
		
	CMP CURR_PLAYER, 1
	JE P2
	MOV COLOR, 02H
	JMP P1
	P2:
		MOV COLOR, 09H
	P1:
		MOV ROW_TOP, 50
		MOV CH, 0
		MOV CL, TEMPB2
		CMP CX, 0
		JLE RDONE
	RFIND:
		ADD ROW_TOP, 20
		LOOP RFIND
		
		
	RDONE:
		MOV CH, ROW_TOP
		MOV ROW_END, CH
		ADD ROW_END, 20
		
		MOV COL_START, 100
		MOV CH, 0
		MOV CL, CURR_COL
		CMP CX, 0
		JLE CDONE
	CFIND:
		ADD COL_START, 20
		LOOP CFIND
		
	CDONE:
		MOV CH, COL_START
		MOV COL_END, CH
		ADD COL_END, 20

		INC ROW_TOP
		DEC ROW_END
		INC COL_START
		DEC COL_END
		
		MOV CH, COL_START
		MOV TEMPB, CH 
		MOV CH, ROW_TOP
		MOV TEMPB2, CH
	DIAGNL1:
		MOV AL, COLOR
		MOV DH, 0
		MOV CH, 0
		MOV DL, ROW_TOP
		MOV CL, COL_START
		MOV AH, 0CH
		INT 10H
		ADD ROW_TOP, 1
		ADD COL_START, 1
		CMP CL,   COL_END
		JB DIAGNL1
		CMP DL,   ROW_END
		JB DIAGNL1
		
		MOV CH, TEMPB
		MOV COL_START, CH 
		MOV CH, TEMPB2
		MOV ROW_TOP, CH
	DIAGNL2:
		MOV AL, COLOR
		MOV DH, 0
		MOV CH, 0
		MOV DL, ROW_END
		MOV CL, COL_START
		MOV AH, 0CH
		INT 10H
		SUB ROW_END, 1
		ADD COL_START, 1
		CMP CL,   COL_END
		JB DIAGNL2
		CMP DL, ROW_TOP
		JA DIAGNL2
		
		CALL PROCESS
		CALL CHECK_SOL
		POP DX
		POP CX
		POP BX		
		POP AX
		RET
CROSS_CELL ENDP

;SETS THE APPROPRIATE BIT IN EACH NUMBER
PROCESS PROC NEAR
	PUSH AX
	PUSH BX
	PUSH CX
	PUSH DX
		
	MOV BX, 0
	MOV BL, CURR_COL 
	MOV  CL, HEIGHT[BX]
	INC CL
	MOV AL, 1
	SHL AL, CL
	CMP CURR_PLAYER, 2
	JNE CPL1
	ADD BL, 6
	CPL1:
		OR PCOL[BX], AL
		
		MOV BX, 0
		MOV BL, CURR_COL 
		MOV  CL, HEIGHT[BX]
		INC CL
		MOV BL, CL
		MOV CL, CURR_COL
		MOV AL, 1
		SHL AL, CL
		CMP CURR_PLAYER, 2
		JNE RPL1
		ADD BL, 6
	RPL1:
		OR PROW[BX], AL
		
		MOV BX, 0
		MOV BL, CURR_COL
		MOV CL, HEIGHT[BX]
		INC CL
		ADD CL, CURR_COL
		SUB CL, 3
		CMP CL, 0
		JB OTHER
		CMP CL, 4
		JA OTHER
		MOV BL, CL
		MOV CL, CURR_COL
		MOV AL, 1
		SHL AL, CL
		CMP CURR_PLAYER, 2
		JNE DPL1
		ADD BL, 5
	DPL1:
		OR PDIAG1[BX], AL
		
	OTHER:
		MOV BX, 0
		MOV BL, CURR_COL
		MOV CL, HEIGHT[BX]
		INC CL
		SUB CL, CURR_COL
		ADD CL, 2
		CMP CL, 0
		JB OTHER1
		CMP CL, 4
		JA OTHER1
		MOV BL, CL
		MOV CL, CURR_COL
		MOV AL, 1
		SHL AL, CL
		CMP CURR_PLAYER, 2
		JNE D2PL1
		ADD BL, 5
	D2PL1:
		OR PDIAG2[BX], AL
		
	OTHER1:
		
		POP DX
		POP CX
		POP BX
		POP AX
		RET
PROCESS ENDP

; CHECKS THE SOLUTION USING BIT METHODS
; CHECK WHETHER FOUR CONSECUTIVE BITS ARE SET IN A NUMBER
CHECK_SOL PROC NEAR
	PUSH AX
	PUSH BX
	PUSH CX
	PUSH DX
		
	MOV BH, 0
	MOV BL, CURR_COL
	CMP CURR_PLAYER, 2
	JNE CRPL1
	ADD BL, 6
	CRPL1:
		MOV AL, PCOL[BX]
		MOV CL, AL
		SHL CL, 1
		AND AL, CL
		MOV CL, AL
		SHL CL, 1
		SHL CL, 1
		AND AL, CL
		JNZ  ASSIST
		
		MOV BH, 0
		MOV BL, CURR_COL 
		MOV  CL, HEIGHT[BX]
		INC CL
		MOV BL, CL
		CMP CURR_PLAYER, 2
		JNE RRPL1
		ADD BL, 6
	RRPL1:
		MOV AL, PROW[BX]
		MOV CL, AL
		SHL CL, 1
		AND AL, CL
		MOV CL, AL
		SHL CL, 1
		SHL CL, 1
		AND AL, CL
		JNZ  ASSIST
		
		MOV BX, 0
		MOV BL, CURR_COL
		MOV CL, HEIGHT[BX]
		INC CL
		ADD CL, CURR_COL
		SUB CL, 3
		CMP CL, 0
		JB OTHERP
		CMP CL, 4
		JA OTHERP
		MOV BL, CL
		CMP CURR_PLAYER, 2
		JNE CPLA1
		ADD BL, 5
	CPLA1:
		MOV AL, PDIAG1[BX]
		MOV CL, AL
		SHL CL, 1
		AND AL, CL
		MOV CL, AL
		SHL CL, 1
		SHL CL, 1
		AND AL, CL
		JNZ OVERG
		
		JMP OTHERP
	ASSIST:
		JMP OVERG
		
		
	OTHERP:
		MOV BX, 0
		MOV BL, CURR_COL
		MOV CL, HEIGHT[BX]
		INC CL
		SUB CL, CURR_COL
		ADD CL, 2
		CMP CL, 0
		JB LAST
		CMP CL, 4
		JA LAST
		MOV BL, CL
		CMP CURR_PLAYER, 2
		JNE CPLA2
		ADD BL, 5
	CPLA2:
		MOV AL, PDIAG2[BX]
		MOV CL, AL
		SHL CL, 1
		AND AL, CL
		MOV CL, AL
		SHL CL, 1
		SHL CL, 1
		AND AL, CL
		JNZ OVERG
		
		JMP LAST
		
	OVERG:
		CALL F_CURSOR
		MOV AH, 09H
		LEA DX, CLEAR
		INT 21H
		CALL F_CURSOR
		CMP CURR_PLAYER, 1
		JNE PRP2
		LEA DX, PLAY1
		JMP PRINTF
	PRP2:
		LEA DX, PLAY2
	PRINTF:
		MOV AH, 09H
		INT 21H
		
		MOV AH, 09H
		LEA DX, FMES
		INT 21H
		
		SET_CURSOR 4,5
		MOV AH, 09H
		LEA DX, CLEAR
		INT 21H
		
		MOV AH, 01H
		INT 21H
		
		CALL INITL

	LAST:
		POP DX
		POP CX
		POP BX
		POP AX
		RET
CHECK_SOL ENDP

; FUNCTION TO SET CURSOR AT 1,5 
; USED INSTEAD OF MACRO TO AVOID JUMP OUT OF RANGE ERROR
F_CURSOR PROC NEAR
	PUSH AX
	PUSH BX
	PUSH CX
	PUSH DX
		
	MOV AH, 02H
	MOV DH, 1
	MOV DL, 5
	MOV BH, 0
	INT 10H
		
	POP DX
	POP CX
	POP BX
	POP AX
	RET
F_CURSOR ENDP

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;                 END OF PROCEDURES                 ;;;;;;;;;
MY_CODE_SEGMENT ENDS
END START
